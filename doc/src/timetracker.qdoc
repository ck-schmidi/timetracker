/*!
    \example timetracker
    \title Simple Timetracker Tutorial
    \brief Demonstrates how to use V-Play to build a timetracking application

    This tutorial will show you how to use V-Play-Apps and QtQuick for creating
    a simple timetracking application.

    \section1 Goal
    The goal of this tutorial is creating a data-based mobile app. We want to have the
    possibility to add and configure projects, where we can then add timetrackings. We
    want to persist this data in a local storage. For this purpose we will use
    \b {Qt Quick Local Storage}. \b{Qt Quick Local Storage} uses a local sqlite database
    for saving the data. The tutorial will also cover how navigation between
    different screens in V-Play-Apps works. We will also build some new controls, like
    a timepicker which is used for selecting a time.

    \section1 Let's get started
    For creating a new V-Play-App we go to \b{File -> New File Or Project} and then
    select \b{Empty Application} in section \b{Project/V-Play Apps}. Select a appropriate
    project-name (I chose \b{timetracking}) and click \b{Next}. Choose the latest
    installed Qt-Version and click \b{Next}. In the next screen you have to enter the app
    display name and the app-identifier. I chose \b{Timetracker} and
    \b{at.codekitchen.timetracker}. Interface orientation can be let to \b{Auto}.
    Choose your prefered source code management tool in the next screen and click
    \b{Finish}

    \section1 Structure
    We will provide the following top-level navigation-structure
    \list
       \li \l{Projects}
       \li \l{Tracking}
       \li \l{Reports}
    \endlist

    So we want to end up with something like this:

    # add screenshot

    Now, let's dive into some code. Open the file \c{qml/Main.qml}

    For top-level navigation we use the V-Play component \c Navigation. \c Navigation is
    renders platform-specific, for example if you are on Android it renders a Drawer-based
    navigation. In iOS its a tab-based navigation.

    So lets build up our top-level UI-Structure by removing whats currently inside \c App
    and add a \c Navigation component with 3x \c NavigationItem as its children for each
    Navigation Entry. \c NavigationItem can be parameterized with a title and an icon. For
    the icons we use the V-Play compontent IconType for getting nice FontAwesome icons.

    \code
    import VPlayApps 1.0

    App {
        Navigation {
            NavigationItem {
                title: qsTr("Trackings")
                icon: IconType.list
            }

            NavigationItem {
                title: qsTr("Projects")
                icon: IconType.trello
            }

            NavigationItem{
                title: qsTr("Reports")
                icon: IconType.file
            }
        }
    }
    \endcode

    If we \b {Build an Run} or project we should see the top-level-navigation of our
    application.


    \section1 Database
    Before we get into programming our different screens, we should talk about the datastructures
    we use in our program.

    We have a simple data structure:

    \code
                                          +-------------------+
        +-------------------+             | Track             |
        | Project           |             +-------------------+
        +-------------------+             |# comment          |
        |# name             |             |# from             |
        |# description      <-------------+# to               |
        +-------------------+             +-------------------+
    \endcode

    We want to organize projects and we want to have timetrackings (track) which can be
    assigned to one of this projects. So lets create a new qml-file \c{qml/Database.qml}
    for encapsulating all our model/database logic.

    In our \c Database component we need to create a database-connection to our \c LocalStorage
    (will be done in the \init() function). The result of the connection is saved in the local
    property db. We also hold two models: \c projectModel for managing projects and trackModel
    for managing our timetrackings.

    For every model we also need some extra logic for handling the model <-> database logic

    In this case we have to Daos (DataAccessObjects) which have following functions:
    \list
       \li \c{populate}: \e{populates the model from database}
       \li \c{append(item)}: \e{appends an new item to the model}
       \li \c{remove(index)}: \e(removes an item from the model by given index}
       \li \c{save(index)}: \e{(saves an item from the model by given index)}
    \endlist

    The base structure of this component should look like:

    \code

    Item {
        id: database
        property var db

        property ListModel projectModel: ListModel{}
        property ListModel trackModel: ListModel{}

        function init(){}

        property var projectDao : QtObject{
            function populate(){}
            function append(project){}
            function remove(modelIndex){}
            function save(modelIndex){}
        }

        property var trackDao: QtObject{
            function populate(){}
            function append(track){}
            function remove(modelIndex){}
            function save(modelIndex){}
        }

        Component.onCompleted: {
            database.init()
            database.projectDao.populate()
            database.trackDao.populate()
        }
    }

    \endcode

    Now we get into the individual functions. Let's start with the \c{init()}-function.
    In this function we need to do following things:

    \list
        \li \l{set up database connection}
        \li \l{create database-structure (only on first startup)}
    \endlist

    For setting up our database connection we use the function \c{openDataBaseSync(â€¦)} from
    the LocalStorage QML-componentAfter setting the connection up, we execute the create-statement
    for our database. You should use the 'IF NOT EXISTS'-clause on the create-statements, then the
    statement is only executed on the first startup of the application.

    \code

    function init(){
        db = LocalStorage.openDatabaseSync("TimeTrackingDB", "1.0", "Timetracking Database", 100000);
        db.transaction( function(tx) {
            tx.executeSql('CREATE TABLE IF NOT EXISTS PROJECT(id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT, description TEXT)')
            tx.executeSql('CREATE TABLE IF NOT EXISTS TRACK(id INTEGER PRIMARY KEY AUTOINCREMENT, comment TEXT, projectid INTEGER, start DATETIME, end DATETIME)')
        });
    }

    \endcode

    If we \b{Build and Run} our application after implementing the \c{init}-function and doesn't
    get any error, the connection succeeded and the database and its tables were created.


    Now let's implement the playerDao and let's start with the \c{populate}-function:

    \list
        \li \l{We first check, if we our db property has a value. if not -> return false}
        \li \l{If we have a valid database-connection we start a transaction}
        \li \l{In this transaction we execute the statement 'SELECT * FROM PROJECT' which returns all entries in table PROJECT}
        \li \l{In the next step we iterate the result-set of this statement and add the project to our projectModel}
    \endlist

    As you can see, we also save us the \c rowId of the database-entry, so we can identify our project-item for updates and
    deletions. We use the javascript \c{parseInt} function for converting the id from the database to an int-value.

    \code
    function populate(){
        if(!db){ return false; }

        db.transaction(function(tx){
            var result = tx.executeSql('SELECT * FROM PROJECT')
            for(var i = 0; i < result.rows.length; i++){
                var item = result.rows.item(i)
                projectModel.append({"rowId": parseInt(item.id), "name": item.name, "description": item.description})
            }
        });
        return true;
    }
    \endcode

    In the next step we will take a look on the \c{append}-function:

    \list
        \li \l{For continuity we reset our name and description properties to an empty string, if they are undefined}
        \li \l{In the next step we execute an INSERT-statement with our project-properties name and description}
        \li \l{After the execution of the statement we save the retured rowId from the database and add the item to our model}
    \endlist

    \code
    function append(project){
        project.name = project.name !== undefined ? project.name : ""
        project.description = project.description !== undefined ? project.description: ""
        db.transaction( function(tx) {
            var res = tx.executeSql('INSERT INTO PROJECT (name, description) VALUES(?, ?)', [project.name, project.description])
            //change rowId before inserting to model
            project.rowId = parseInt(res.insertId)
        })
        projectModel.append(project)
        return projectModel.count - 1
    }
    \endcode

    Now lets implement the remove function:

    \list
        \li \l{The remove-function takes the modelIndex as a parameter, so we take our project from the model with the given index}
        \li \l{In the next step again open a database-transaction and execute the DELETE-statement}
        \li \l{For checking the success of the delete-statement we check the rowsAffected property on our statement-result}
        \li \l{If the deletion was successful, we remove the given project from our model and return true, otherwise we return false}
    \endlist

    \code
    function remove(modelIndex){
        var project = projectModel.get(modelIndex)
        var success
        db.transaction( function(tx) {
            var res = tx.executeSql('DELETE FROM PROJECT WHERE id = ?', [project.rowId])
            success = res.rowsAffected > 0
        })

        if(!success) { return false; }
        projectModel.remove(modelIndex)
        return true
    }
    \endcode


    In the last step of the \c{projectDao} implementation we implement to \c{save} function.

    \list
        \li \l{similar to the remove-function we first get the project from the model with the given index}
        \li \l{In the next step we open a new database-transaction and execute the UPDATE-statement}
        \li \l{If res.rowsAffected > 0, we return true, otherwise we return false}
    \endlist

    \code
    function save(modelIndex){
        var project = projectModel.get(modelIndex)
        var success
        db.transaction(function(tx){
            var res = tx.executeSql('UPDATE PROJECT SET name = ?, description = ? WHERE id = ?', [project.name, project.description, project.rowId])
            success = res.rowsAffected > 0
        });
        return success
    }
    \endcode

    # todo: add instructions for trackDao (maybe some simple instructions whats different from projectDao, otherwise its too much similarity)


    \section1 First Screen ProjectPage

    We want to have a screen, where we can Add, Modify and Delete projects.
    When we go to the screen it should look like:

    # todo insert screenshot
    Let's create an empty QML-Component \c{ProjectsPage.qml} for our visual implementation.

    After creating the new qml-file lets use it in our \c{Main.qml} component within a \c{NavigationStack} (needed
    for our Detail-Page)

    \code
        ...

        NavigationItem {
            title: qsTr("Projects")
            icon: IconType.trello

            NavigationStack{
                ProjectsPage{}
            }
        }
        ...

    \endcode

    Now lets dive into \c{ProjectPage.qml}

    Our toplevel-component is a \c{ListPage} where we set the title to 'Projects'

    \code

    ListPage {
        title: qsTr("Projects")
        ...
    }

    \endcode


    For adding new projects we add a "+" - Button to the rightBarItem

    \code
    ListPage{
        ...
        rightBarItem: IconButtonBarItem {
            icon: IconType.plus
        }
        ...
    \endcode


    Now we need a \c{ListView} for showing our entries from the database.

    Let's add a \c{AppListView}, which provides a nice device-independent \c{ListView}

    \c{AppListView} takes our database.projectModel as a model and we use the \c{SimpleRow}
    delegate for displaying our data (text should be the (project)name, detailText
    the (project)description)

    \code

    ListPage{
        ...
        AppListView {
            id: appListView
            model: database.projectModel
            delegate: SimpleRow {
                text: name
                detailText: description
            }
        }
        ...
    \endcode


    For using our database we need to instantiate it in global scope (\c{Main.qml})
    In this step we also add the \c{id} app (we will need this later)

    \code
    App {
        id: app

        Database{
            id: database
        }
        ...

    \endcode

    After this step we are able to show project-entries from the model (database)

    In the next step we want to provide functionality for adding new projects.

    So, let's add a function which opens a Dialog with a TextField for entering the
    name of the new project.

    \c{InputDialog} is a V-Play Component which provides single and multiline
    InputDialogs. In this case we one need a singleline input so we use the function
    \c{inputTextSingleLine}. It takes the topel-level app, a title, a placeholder-text
    and a callback-function, where we can handle the users actions and inputs.

    In the callback-function we check if "Cancel" was pressed (!ok) or the input-text
    is empty. If one of these conditions is true, we return and do nothing

    Otherwise we call our \c{projectDao.append(...)} function.

    \code
    function createNewProject(){
        InputDialog.inputTextSingleLine(app,
                                        qsTr("Create new Project"),
                                        qsTr("Project Name"),
                                        function (ok, text) {
                                            if (!ok || text === "") {
                                                return
                                            }
                                            database.projectDao.append({"name": text, "description": "")
                                        })
    }
    \endcode

    Let's use this function on our rightBarItem in the onClicked event-handler:

    \code
    rightBarItem: IconButtonBarItem {
        ...
        onClicked: createNewProject()
    }
    \endcode

    Now we are able to create new projects by clicking the "+"-Button and filling the LineEdit.

*/
