/*!
    \example timetracker
    \title Simple Timetracker Tutorial
    \brief Demonstrates how to use V-Play to build a timetracking application

    This tutorial will show you how to use V-Play-Apps and QtQuick for creating
    a simple timetracking application.

    \section1 Goal
    The goal of this tutorial is creating a data-based mobile app. We want to have the
    possibility to add and configure projects, where we can then add timetrackings. We
    want to persist this data in a local storage. For this purpose we will use
    \b {Qt Quick Local Storage}. \b{Qt Quick Local Storage} uses a local sqlite database
    for saving the data. The tutorial will also cover how navigation between
    different screens in V-Play-Apps works. We will also build some new controls, like
    a timepicker which is used for selecting a time.

    \section1 Let's get started
    For creating a new V-Play-App we go to \b{File -> New File Or Project} and then
    select \b{Empty Application} in section \b{Project/V-Play Apps}. Select a appropriate
    project-name (I chose \b{timetracking}) and click \b{Next}. Choose the latest
    installed Qt-Version and click \b{Next}. In the next screen you have to enter the app
    display name and the app-identifier. I chose \b{Timetracker} and
    \b{at.codekitchen.timetracker}. Interface orientation can be let to \b{Auto}.
    Choose your prefered source code management tool in the next screen and click
    \b{Finish}

    \section1 Structure
    We will provide the following top-level navigation-structure
    \list
       \li Projects
       \li Tracking
       \li Reports
    \endlist

    So we want to end up with something like this:

    \image navigation.png

    Now, let's dive into some code. Open the file \c{qml/Main.qml}

    For top-level navigation we use the V-Play component \c Navigation. \c Navigation
    renders platform-specific, for example if you are on Android it renders a Drawer-based
    navigation. In iOS its a tab-based navigation.

    So lets build up our top-level UI-Structure by removing whats currently inside \c App
    and add a \c Navigation component with 3x \c NavigationItem as its children for each
    Navigation Entry. \c NavigationItem can be parameterized with a title and an icon. For
    the icons we use the V-Play compontent IconType for getting nice FontAwesome icons.

    \code
    import VPlayApps 1.0

    App {
        Navigation {
            NavigationItem {
                title: qsTr("Trackings")
                icon: IconType.list
            }

            NavigationItem {
                title: qsTr("Projects")
                icon: IconType.trello
            }

            NavigationItem{
                title: qsTr("Reports")
                icon: IconType.file
            }
        }
    }
    \endcode

    If we \b {Build an Run} our project we should see the top-level-navigation of our application.

    \section1 Database
    Before we get into programming our different screens, we should talk about the datastructures
    we use in our program.

    We have a simple data structure:

    \code
                                          +-------------------+
        +-------------------+             | Track             |
        | Project           |             +-------------------+
        +-------------------+             |# comment          |
        |# name             |             |# from             |
        |# description      <-------------+# to               |
        +-------------------+             +-------------------+
    \endcode

    We want to organize projects and we want to have timetrackings (track) which can be
    assigned to one of this projects. So lets create a new qml-file \c{qml/Database.qml}
    for encapsulating all our model/database logic.

    In our \c Database component we need to create a database-connection to our \c LocalStorage
    (will be done in the \c{init} function). The result of the connection is saved in the local
    property db. We also hold two models: \c projectModel for managing projects and trackModel
    for managing our timetrackings.

    For every model we also need some extra logic for handling the model <-> database logic

    In this case we have to Daos (DataAccessObjects) which have following functions:
    \list
       \li \c{populate}: \e{populates the model from database}
       \li \c{append(item)}: \e{appends an new item to the model}
       \li \c{remove(index)}: \e(removes an item from the model by given index}
       \li \c{save(index)}: \e{(saves an item from the model by given index)}
    \endlist

    For our \c{projectDao} we will implement also two helper functions for finding projects
    by their rowId

    The base structure of this component should look like:

    \code

    Item {
        id: database
        property var db

        property ListModel projectModel: ListModel{}
        property ListModel trackModel: ListModel{}

        function init(){}

        property var projectDao : QtObject{
            function populate(){}
            function append(project){}
            function remove(modelIndex){}
            function save(modelIndex){}
            function getIndexByRowId(rowId){}
            function getProjectByRowId(rowId){}
        }

        property var trackDao: QtObject{
            function populate(){}
            function append(track){}
            function remove(modelIndex){}
            function save(modelIndex){}
        }

        Component.onCompleted: {
            database.init()
            database.projectDao.populate()
            database.trackDao.populate()
        }
    }

    \endcode

    Now we get into the individual functions. Let's start with the \c{init()}-function.
    In this function we need to do following things:

    \list
        \li set up database connection
        \li create database-structure (only on first startup)
    \endlist

    For setting up our database connection we use the function \c{openDataBaseSync(â€¦)} from
    the LocalStorage QML-component. After setting the connection up, we execute the create-statement
    for our database. You should use the 'IF NOT EXISTS'-clause on the create-statements, then the
    statement is only executed on the first startup of the application.

    \code

    function init(){
        db = LocalStorage.openDatabaseSync("TimeTrackingDB", "1.0", "Timetracking Database", 100000);
        db.transaction( function(tx) {
            tx.executeSql('CREATE TABLE IF NOT EXISTS PROJECT(id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT, description TEXT)')
            tx.executeSql('CREATE TABLE IF NOT EXISTS TRACK(id INTEGER PRIMARY KEY AUTOINCREMENT, comment TEXT, projectid INTEGER, start DATETIME, end DATETIME)')
        });
    }

    \endcode

    If we \b{Build and Run} our application after implementing the \c{init}-function and doesn't
    get any error, the connection succeeded and the database and its tables were created.


    Now let's implement the playerDao and let's start with the \c{populate}-function:

    \list
        \li We first check, if we our db property has a value. if not -> return false
        \li If we have a valid database-connection we start a transaction
        \li In this transaction we execute the statement 'SELECT * FROM PROJECT' which returns all entries in table PROJECT
        \li In the next step we iterate the result-set of this statement and add the project to our projectModel
    \endlist

    As you can see, we also save us the \c rowId of the database-entry, so we can identify our project-item for updates and
    deletions. We use the javascript \c{parseInt} function for converting the id from the database to an int-value.

    \code
    function populate(){
        if(!db){ return false; }

        db.transaction(function(tx){
            var result = tx.executeSql('SELECT * FROM PROJECT')
            for(var i = 0; i < result.rows.length; i++){
                var item = result.rows.item(i)
                projectModel.append({"rowId": parseInt(item.id), "name": item.name, "description": item.description})
            }
        });
        return true;
    }
    \endcode

    In the next step we will take a look on the \c{append}-function:

    \list
        \li For continuity we reset our name and description properties to an empty string, if they are undefined
        \li In the next step we execute an INSERT-statement with our project-properties name and description
        \li After the execution of the statement we save the retured rowId from the database and add the item to our model
    \endlist

    \code
    function append(project){
        project.name = project.name !== undefined ? project.name : ""
        project.description = project.description !== undefined ? project.description: ""
        db.transaction( function(tx) {
            var res = tx.executeSql('INSERT INTO PROJECT (name, description) VALUES(?, ?)', [project.name, project.description])
            //change rowId before inserting to model
            project.rowId = parseInt(res.insertId)
        })
        projectModel.append(project)
        return projectModel.count - 1
    }
    \endcode

    Now lets implement the remove function:

    \list
        \li The remove-function takes the modelIndex as a parameter, so we take our project from the model with the given index
        \li In the next step again open a database-transaction and execute the DELETE-statement
        \li For checking the success of the delete-statement we check the rowsAffected property on our statement-result
        \li If the deletion was successful, we remove the given project from our model and return true, otherwise we return false
    \endlist

    \code
    function remove(modelIndex){
        var project = projectModel.get(modelIndex)
        var success
        db.transaction( function(tx) {
            var res = tx.executeSql('DELETE FROM PROJECT WHERE id = ?', [project.rowId])
            success = res.rowsAffected > 0
        })

        if(!success) { return false; }
        projectModel.remove(modelIndex)
        return true
    }
    \endcode


    In the next step of the \c{projectDao} implementation we implement the \c{save} function.

    \list
        \li similar to the remove-function we first get the project from the model with the given index
        \li In the next step we open a new database-transaction and execute the UPDATE-statement
        \li If res.rowsAffected > 0, we return true, otherwise we return false
    \endlist

    \code
    function save(modelIndex){
        var project = projectModel.get(modelIndex)
        var success
        db.transaction(function(tx){
            var res = tx.executeSql('UPDATE PROJECT SET name = ?, description = ? WHERE id = ?', [project.name, project.description, project.rowId])
            success = res.rowsAffected > 0
        });
        return success
    }
    \endcode


    In the next step of the \c{projectDao} we'll implement our two helper functions

    \list
        \li getIndexByRowId simply iterates all projects from the projectModel and return the index of the rowId matches
        \li getProjectByRowId uses this function and just returns the project behind the found index
    \endlist

    \code

    function getIndexByRowId(rowId){
        for(var i = 0; i < projectModel.count; i++){
        var project = projectModel.get(i)
        if(project.rowId === rowId)
            return i
        }
        return -1
    }

    function getProjectByRowId(rowId){
        var index = getIndexByRowId(rowId)
        if(index === -1)
            return undefined;
        return projectModel.get(index)
    }

    \endcode


   The DAO-Code for the trackDao is pretty similar to the projectModel.
   I'll outline the main differences, but I won't go into every function explicitly.

   The main difference to the projectModel is, that we have to care about the
   relationship between the track and the project.

   \list
       \li {In the function populate() we also save the projectRowId as our foreign-key}
       \li {Our append function sets the default values for start, end and project(selects the last created project)}
   \endlist

    \code

    //holds all the model-functionality for trackModel
    property var trackDao: QtObject{
        function populate(){
            if(!db){ return false; }
            db.transaction(function(tx){
                var result = tx.executeSql('SELECT * FROM TRACK')
                for(var i = 0; i < result.rows.length; i++){
                    var item = result.rows.item(i)
                    trackModel.append({"rowId": parseInt(item.id),
                                       "comment": item.comment,
                                       "projectRowId": item.projectid,
                                       "start": item.start,
                                       "end": item.end})
                }
            });
            return true;
        }

        function append(track){
            track.comment = track.comment !== undefined ? track.comment : ""
            track.start = new Date(Date.now())
            track.end = new Date(Date.now())

            var lastProject = projectModel.get(projectModel.count - 1)
            if (lastProject){
                track.projectRowId = lastProject.rowId
            }
            else{
                track.projectRowId = -1
            }

            var res
            db.transaction( function(tx) {
                res = tx.executeSql('INSERT INTO TRACK(comment, projectid, start, end) VALUES(?, ?, ?, ?)',
                                    [track.comment, track.projectRowId, track.start, track.end])
                track.rowId = parseInt(res.insertId)
            })
            trackModel.insert(0, track)
            return 0
        }

        function remove(modelIndex){
            var track = trackModel.get(modelIndex)
            var success
            db.transaction( function(tx) {
                var res = tx.executeSql('DELETE FROM TRACK WHERE id = ?', [track.rowId])
                success = res.rowsAffected > 0
            })
            if(!success) { return success; }
            trackModel.remove(modelIndex)
            return success
        }

        function save(modelIndex){
            var track = trackModel.get(modelIndex)
            var success
            db.transaction(function(tx){
                var res = tx.executeSql('UPDATE TRACK SET comment = ?, start = ?, end = ?, projectid = ? WHERE id = ?',
                                        [track.comment, track.start, track.end, track.projectRowId])
                success = res.rowsAffected > 0
            });
            return success
        }
    }


    \endcode


    \section1 Screen ProjectsPage

    We want to have a screen, where we can Add, Modify and Delete projects.
    When we go to the screen it should look like:

    \image projects.png 

    Let's create an empty QML-Component \c{ProjectsPage.qml} for our visual implementation.

    After creating the new qml-file lets use it in our \c{Main.qml} component within a \c{NavigationStack} (needed
    for our Detail-Page)

    \image projects_details.png 

    \code
        ...

        NavigationItem {
            title: qsTr("Projects")
            icon: IconType.trello

            NavigationStack{
                ProjectsPage{}
            }
        }
        ...

    \endcode

    Now lets dive into \c{ProjectsPage.qml}

    Our toplevel-component is a \c{ListPage} where we set the title to 'Projects'

    \code

    ListPage {
        title: qsTr("Projects")
        ...
    }

    \endcode


    For adding new projects we add a "+" - Button to the rightBarItem

    \code
    ListPage{
        ...
        rightBarItem: IconButtonBarItem {
            icon: IconType.plus
        }
        ...
    \endcode


    Now we need a \c{ListView} for showing our entries from the database.

    Let's add a \c{AppListView}, which provides a nice device-independent \c{ListView}

    \c{AppListView} takes our database.projectModel as a model and we use the \c{SimpleRow}
    delegate for displaying our data (text should be the (project)name, detailText
    the (project)description)

    \code

    ListPage{
        ...
        AppListView {
            id: appListView
            model: database.projectModel
            delegate: SimpleRow {
                text: name
                detailText: description
            }
        }
        ...
    \endcode


    For using our database we need to instantiate it in global scope (\c{Main.qml})
    In this step we also add the \c{id} app (we will need this later)

    \code
    App {
        id: app

        Database{
            id: database
        }
        ...

    \endcode

    After this step we are able to show project-entries from the model (database)

    In the next step we want to provide functionality for adding new projects.

    So, let's add a function which opens a Dialog with a TextField for entering the
    name of the new project.

    \c{InputDialog} is a V-Play Component which provides single and multiline
    InputDialogs. In this case we one need a singleline input so we use the function
    \c{inputTextSingleLine}. It takes the topel-level app, a title, a placeholder-text
    and a callback-function, where we can handle the users actions and inputs.

    In the callback-function we check if "Cancel" was pressed (!ok) or the input-text
    is empty. If one of these conditions is true, we return and do nothing

    Otherwise we call our \c{projectDao.append(...)} function.

    \code
    function createNewProject(){
        InputDialog.inputTextSingleLine(app,
                                        qsTr("Create new Project"),
                                        qsTr("Project Name"),
                                        function (ok, text) {
                                            if (!ok || text === "") {
                                                return
                                            }
                                            database.projectDao.append({"name": text, "description": "")
                                        })
    }
    \endcode

    Let's use this function on our rightBarItem in the onClicked event-handler:

    \code
    rightBarItem: IconButtonBarItem {
        ...
        onClicked: createNewProject()
    }
    \endcode

    Now we are able to create new projects by clicking the "+"-Button and filling the LineEdit.

    In the next step we implement a DetailScreen for our ListView.

    For this purpose we create a new component inside our \c{ProjectsPage}
    The component holds a page with the title 'Detail View'

    We add two properties \c{projectIndex} + \c{project}.
    \c{projectIndex} is used as parameter for the DetailView

    \code

    ListPage {
        ...
        Component {
        id: detailView
            Page {
                id: page
                title: qsTr("Detail View")

                property int projectIndex
                property var project: database.projectModel.get(projectIndex)
            }
        }
        ...
    \endcode

    For using this component we have to extend our implementation of our \c{AppListView}
    We add a function \c{switchTo(index)} for pushing our detailView to our navigationStack
    and use it in our \c{SimpleRow}-delegate

    \code
    AppListView {
        ...
        delegate: SimpleRow {
            ...
            onSelected: appListView.switchTo(index)
        }
        ...
        function switchTo(index) {
            navigationStack.push(detailView, { projectIndex: index })
        }
        ...
    \endcode

    We can also change our \c{createNewProject} function to switch to the detail-screen
    after creating the new project

    \code

    function createNewProject(){
        ...
                                            appListView.switchTo(database.projectDao.append({"name": text, "description": ""}))
        ...
    }

    \endcode

    Now lets extend our DetailView for editing the project:

    In the first step we add a \c{Column} container for providing all our labels and textfields:

    For our Labels we create a new component \c{AppTextFieldLabel.qml} in a new folder \c{components} for preventing code-replication:

    \code

    AppText{
        font.pixelSize: sp(10)
        color: "grey"
    }

    \endcode

    We use the VPlay-App components \c{AppText} and \c{AppTextField} for the labels and textfields:

    \code
    Component {
        id: detailView
        Page {
            ...
            Column{
                spacing: dp(5)
                topPadding: dp(15)
                padding: dp(5)

                AppTextFieldLabel{
                    id: projectNameLabel
                    text: qsTr("Project Name:")
                    width: col.width - 2 * col.spacing
                }

                AppTextField{
                    id: projectNameTextField
                    text:  project ? project.name : ""
                    width: col.width - 2 * col.spacing
                    onTextChanged: saveTimer.restart()
                }

                AppTextFieldLabel{
                    id: projectDescriptionLabel
                    text: qsTr("Project Description:")
                    width: col.width - 2 * col.spacing
                }

                AppTextField{
                    id: projectDescriptionTextField
                    text:  project ? project.description: ""
                    width: col.width - 2 * col.spacing
                    onTextChanged: saveTimer.restart()
                }
            }
            ...
    \endcode

    After that change, our DetailView shows the correct informations from the database, but
    editing still doesn't work correctly

    We have to add the Bindings for 2-way-property binding (see: \l{http://imaginativethinking.ca/bi-directional-data-binding-qt-quick/})
    and we add a timer for saving our changes (not too often ;))

    \code
        Binding{
            target: project
            property: "name"
            value: projectNameTextField.text
        }

        Binding{
            target: project
            property: "description"
            value: projectDescriptionTextField.text
        }

        Timer{
            id: saveTimer
            interval: 500
            running: false
            repeat: false
            onTriggered: database.projectDao.save(projectIndex)
        }
    \endcode

    We need to call this functions when our texts in the textfields gets changed

    \code

    AppTextField{
        id: projectNameTextField
        ...
        onTextChanged: saveTimer.restart()
    }

    AppTextField{
        id: projectDescriptionTextField
        ...
        onTextChanged: saveTimer.restart()
    }

    \endcode

    Our last task for the Project-Detail-View is adding a delete button:

    In this case we create a new component \c{DeleteButton.qml} which encapsulates
    our DeleteButton. We use the \c{AppButton} component from V-Play-Apps with a
    remove-icon and text "delete" and some appropriate colors.

    \code
    AppButton{
        id: deleteButton
        text: qsTr("delete")
        icon: IconType.remove
        backgroundColor: "red"
        backgroundColorPressed: "purple"
    }
    \endcode

    Similar to the text creating we again use the \c{InputDialog} component
    for creating an Dialog. In this case we just want to confirm the deletion.
    If the user confirms the deletion, we use our model-functions to remove it

    \code
            Column{
                ...
                DeleteButton{
                    id: deleteButton
                    onClicked: {
                        InputDialog.confirm(app,
                           qsTr("Really wanna delete project %1?".arg(project.name)),
                           function (ok) {
                               if (!ok) { return; }
                               database.projectDao.remove(page.projectIndex)
                               navigationStack.pop()
                           })
                    }
                }
            }
    \endcode

    Now we are done with the ProjectView.

    \section1 Screen TrackingsPage

    \c{TrackingsPage} is pretty similar to \c{ProjectsPage}. It contains a \c{ListView} with
    all trackings, an Add-Button and a DetailView.

    It should look like:

    \image trackings.png

    with a detail screen:

    \image trackings_detail.png

    and a Date/Time-picker screen for changing date and time

    \image datetimepicker.png


    Let's create a QML-component \c{TrackingsPage.qml}

    Again, I won't go too much into the details, because its very similar to the ProjectsPage.
    Instead of opening a Dialog when clicking the "+"-Button, we directly append a new track
    to the model and switch to the DetailView for editing.

    \code

    ListPage{
        id: trackingsPage
        title: qsTr("Trackings")

        Component{
            id: detailView
            Page{
                title: qsTr("Detail View")
                property int trackIndex
                property var track: database.trackModel.get(trackIndex)
            }
        }

        rightBarItem: IconButtonBarItem {
            icon: IconType.plus
            onClicked: {
                appListView.switchTo(database.trackDao.append({comment: ""}))
            }
        }

        AppListView{
            id: appListView
            model: database.trackModel

            delegate: SimpleRow {
                text: "Project: %1".arg(database.projectDao.getProjectByRowId(model.projectRowId))
                detailText: "%1 (%2)".arg(Helpers.formatDate(model.start)).arg(model.comment)
                onSelected: appListView.switchTo(index)
            }

            function switchTo(index) {
                navigationStack.push(detailView, {trackingIndex: index })
            }
        }
    }

    \endcode

    In our \c{SimpleRow} delegate we use a helper-function formatDate(...) which we put in a new file \c{helpers.js}
    This function does the formatting of your date.

    \code

    .pragma library

    function formatDate(dt)
    {
        dt = new Date(dt);

        var formattedDate = '%1.%2.%3 %4:%5'
        .arg(padLeft(dt.getDate(), '0', 2))
        .arg(padLeft(dt.getMonth() + 1, '0', 2))
        .arg(dt.getFullYear())
        .arg(padLeft(dt.getHours(), '0', 2))
        .arg(padLeft(dt.getMinutes(), '0', 2))

        return formattedDate
    }

    function padLeft(str, ch, width)
    {
        var s = String(str);

        while (s.length < width)
        s = ch + s;

        return s;
    }

    \endcode


    Now we can use the \c{TrackingsPage} in \c{Main.qml}

    \code
    Navigation {
        NavigationItem {
            ...
            NavigationStack{
                TrackingsPage{}
            }
        }
    \endcode

    In the next step we will create some components, which we will later on need for
    our TrackingsPage. We will start with the TimePicker.

    Let's create a new file \c{TimePicker.qml} in the folder components.

    The implementation of \c{TimePicker.qml} is pretty straight-forward

    \list
        \li As top-level component we choose Item
        \li Lets add a property visibleItem for configuring how many items  should be shown in the tumbler-list
        \li Create a Text-Component for our Tumbler-delegate which cares about the styling of the single text-line
        \li Add a row with 2 Tumblers (one for hours, one four minutes) + identify them by setting an id
        \li Lets add the property aliases currentHours and currentMinutes to our Tumblers curent index
        \li For simpler usage we provide a new signal anyValueChanged which is fired by onCurrentHoursChanged and onCurrentMinutesChanged
    \endlist

    \code
    import VPlay 2.0
    import QtQuick 2.7
    import QtQuick.Controls 2.0

    Item{
        height: dp(100)
        width: row.width

        property int visibleItems: 3
        property alias currentHours: hourTumbler.currentIndex
        property alias currentMinutes: minutesTumbler.currentIndex

        signal anyValueChanged

        onCurrentHoursChanged: anyValueChanged()
        onCurrentMinutesChanged: anyValueChanged()

        Component{
            id: tumblerDelegate
            Text{
                text: {
                    if(modelData < 10)
                        return "0" + modelData
                    return modelData
                }
                horizontalAlignment: Text.AlignHCenter
                verticalAlignment: Text.AlignVCenter
                font.pixelSize: dp(20)
                opacity: 1.0 - Math.abs(Tumbler.displacement) / (visibleItems / 2)
            }
        }

        Row{
            id: row
            Tumbler {
                id: hourTumbler
                width: dp(50)
                model: 24
                delegate: tumblerDelegate
            }
            Tumbler {
                id: minutesTumbler
                width: dp(50)
                model: 60
                delegate: tumblerDelegate
            }
        }
    }
    \endcode

    Another component we will probably need at some more points will be a \c{AppTextFieldLabel} which
    is used for labeling controls on the screens.

    We just set \c{font.pixelSize} and \c{color} to some appropriate values.

    \code

    import VPlayApps 1.0
    import QtQuick 2.0

    AppText{
        font.pixelSize: sp(10)
        color: "grey"
    }

    \endcode

    Now let' complete our \c{TrackingPage}. First of all, we will add a new Component inside our \c{ListPage}

    \list
        \li We use a page with gets parameterized with 2 values: date and callback
        \li date is the date/time we want to show and edit
        \li callback is the function which is called which callback(date), when the date/time gets changed by the user
        \li For this purpose we have the function returnDate which creates the date and calls the callback-function
        \li We have a column with a QtQuick1 Calender and our own Component TimePicker inside a Flickable for a better overflow-behaviour
        \li In the function Component.onCompleted we initilize our Component after dynamic loading
    \endlist

    \code
    ...

    Component{
        id: dateTimePickerView

        Page{
            id: page
            title: qsTr("Pick Date and Time")

            property var date
            property var callback

            function returnDate(){
                var date = calendar.selectedDate
                date.setHours(timePicker.currentHours)
                date.setMinutes(timePicker.currentMinutes)
                callback(date)
            }

            Flickable{
                anchors.fill: parent
                contentHeight: col.height
                interactive: contentHeight > col.heightd

                Column{
                    id: col
                    padding: dp(15)
                    spacing: padding
                    anchors.left: parent.left
                    anchors.right: parent.right


                    QQC1.Calendar{
                        id: calendar
                        width: col.width / 4 * 3
                        height: width
                        anchors.horizontalCenter: parent.horizontalCenter
                        onSelectedDateChanged: page.returnDate()
                    }

                    TimePicker{
                        id: timePicker
                        anchors.horizontalCenter: parent.horizontalCenter
                        onAnyValueChanged: page.returnDate()
                    }
                }
            }

            Component.onCompleted: {
                var date = page.date
                if(date.getTime() === 0){
                    date = new Date(Date.now())
                }

                calendar.selectedDate = date
                timePicker.currentHours = date.getHours()
                timePicker.currentMinutes = date.getMinutes()
            }
        }
    }
    ...

    \endcode

    Now we have a working screen for choosing date and time, so lets change our DetailView
    and use the new component.

    Now lets add some new code to our detailView:

    \list
        \li We also need a Column for aranging our Labels, Combobox,...
        \li Lets add the TextLabels, ComboBox, TextFields, DeleteButton to our Column
        \li Delete-Button-behaviour is pretty similar to the ProjectsPage
        \li Similar to dateTimePickerView we also uses a more imperative logic in this case
        \li We have a function updateDateTimeTexts() which updates our textfields with the set dates
        \li In Component.onCompleted we initialize our screen (update start/end-text + update combobox-value)
        \li For ComboBox we use the onCurrentIndexChanged eventHandler for updating our model after change
        \li We put some MouseAreas over the AppTextFields to prevent changing the text directly, instead we switch to the DateTimePickerView
    \endlist

    \code
    Component{
        ...
        Page{
            ...
            Column{
                id: col
                spacing: dp(5)
                topPadding: dp(15)
                padding: dp(5)
                anchors.fill: parent

                AppTextFieldLabel{
                    id: projectComboBoxLabel
                    text: qsTr("Project:")
                    width: col.width - 2 * col.spacing
                }

                QQC2.ComboBox{
                    id: projectComboBox
                    textRole: "name"
                    model: database.projectModel
                    width: col.width - 2 * col.spacing
                    currentIndex: -1

                    onCurrentIndexChanged: {
                        if(currentIndex < 0) {return;}
                        page.track.projectRowId = database.projectModel.get(currentIndex).rowId
                        database.trackDao.save(page.trackIndex)
                    }
                }

                AppTextFieldLabel{
                    id: startTextLabel
                    text: qsTr("Start Time")
                    width: col.width - 2 * col.spacing
                }

                AppTextField{
                    id: startText
                    width: col.width - 2 * col.spacing
                    MouseArea{
                        anchors.fill: parent
                        onClicked: appListView.switchToDateTimePickerView(track.start, function(date){
                            page.track.start = date
                            database.trackDao.save(page.trackIndex)
                            page.updateDateTimeTexts()
                        });
                    }
                }

                AppTextFieldLabel{
                    id: endTextLabel
                    text: qsTr("End Time")
                    width: col.width - 2 * col.spacing
                }

                AppTextField{
                    id: endText
                    width: col.width - 2 * col.spacing
                    MouseArea{
                        anchors.fill: parent
                        onClicked: appListView.switchToDateTimePickerView(track.end, function(date){
                            page.track.end = date
                            database.trackDao.save(page.trackIndex)
                            page.updateDateTimeTexts()
                        });
                    }
                }

                DeleteButton{
                    id: deleteButton
                    anchors.horizontalCenter: parent.horizontalCenter
                    onClicked: {
                        InputDialog.confirm(app,
                           qsTr("Really wanna delete this timetracking?"),
                           function (ok) {
                               if (!ok) { return; }
                               database.trackDao.remove(page.trackIndex)
                               navigationStack.pop()
                           })
                    }
                }

            }

            function updateDateTimeTexts(){
                if(!page.track){ return; }
                startText.text = page.track ? Helpers.formatDate(page.track.start) : ""
                endText.text = page.track ? Helpers.formatDate(page.track.end): ""
            }

            Component.onCompleted: {
                if(!page.track){ return; }
                updateDateTimeTexts()
                var index = database.projectDao.getIndexByRowId(page.track.projectRowId)
                projectComboBox.currentIndex = index
            }
        }
    }
    \endcode


    For switching to our new component DateTimePickerView we need some more functionality in our
    ListPage. Similar to switchTo(...) we now provide a function \c{switchToDateTimePickerView}
    for switching to our DateTimePickerView. We also do some changes on our text Property of \c{SimpleRow}
    We just return the project.name, if we can find a related project

    \code

    AppListView{
        ...
        delegate: SimpleRow {
            text: {
                var project = database.projectDao.getProjectByRowId(model.projectRowId)
                if(!project){ return "";}
                return "Project: %1".arg(project.name)
            }
            ...
        }

        function switchToDateTimePickerView(date, callback){
            navigationStack.push(dateTimePickerView, {date: date, callback: callback})
        }
    }

    \endcode

    \section1 ReportsPage

    In the last part of our tutorial we'll build a simple Report-View which sums up our worked hours
    per week.

    It should look like:

    \image report.png

    where we can select a project, the result page should look like:

    \image report_detail.png

    Let's create a new QML-File \c{ReportsPage.qml} and integrate it in \c{Main.qml} (the same way as
    \c{ProjectsPage.qml} and \c{TrackingsPage.qml}}


    Let's add some content:

    Again we use \c{ListPage} as our toplevel-component.

    \list
        \li Add new Component reportResult which contains a simple Page with two paramaters (string projectName, var reportModel
        \li Add a Column for our Report-Form
        \li Add a QtQuickControls2 ComboBox and an AppButton for selecting a project and start the reporting
    \endlist


    \code

    ListPage {
        id: reportPage
        title: qsTr("Create report")

        Component {
            id: reportResult
            Page {
                id: page
                title: qsTr("Result")

                property string projectName
                property var reportModel
            }
        }

        Column{
            id: col
            anchors.fill: parent
            padding: dp(5)
            spacing: dp(5)

            QQC2.ComboBox{
                id: projectComboBox
                textRole: "name"
                model: database.projectModel
                width: col.width - 2 * col.spacing
            }

            AppButton{
                text: qsTr("show report")
            }
        }
    }

    \endcode

    For our reporting we need some functionality for extracting our report.

    Let's go to \c{Database.qml} and add a function \c{getReport(...)}.
    In our function we again open an new database-transaction and execute a sql-statement which
    takes the sum over the difference of end and start and groups ther results per week.

    After executing the statement we iterate the result and bring the result in a form, that is
    nice to use for iterating in QML.

    \code

    Item {
        id: database
        ...
        function getReport(projectRowId){
            var result
            db.transaction(function(tx){
                result = tx.executeSql('SELECT strftime("%W", START) AS week, ROUND(SUM(((julianday(END) - julianday(START))*24)), 2) as result FROM TRACK WHERE projectid = ? GROUP BY WEEK',
                       [projectRowId])
            });
            var report = []
            for(var i = 0; i < result.rows.length; i++){
                var item = result.rows.item(i)
                report = report.concat(item)
            }
            return report
        }
        ...
    }

    \endcode

    Now we have the functionality for creating report for a certain project.
    Lets integrate it to our views.

    So lets modify our \c{Component} "pageResult"

    \list

    \li We start by adding a Column to our \c{Page}
    \li In this column we add a row with a Label and an AppText (text is set to our component-parameter projectName
    \li For showing the results of our report we place another Column in our Column
    \li In a repeater we iterate over our reportModel
    \li Inside our Repeater we again add a Row for placing the label for the calendar-week and the
        computed result from our function we wrote before

    \endlist


    \code

    Component {
        id: reportResult
        Page {
            id: page
            title: qsTr("Result")

            property string projectName
            property var reportModel

            Column{
                id: col
                anchors.fill: parent
                padding: dp(10)
                spacing: dp(10)

                Row{
                    spacing: dp(5)
                    AppTextFieldLabel{
                        id: projectNameTextLabel
                        text: qsTr("Project Name:")
                    }

                    AppText{
                        id: projectNameText
                        text: projectName
                        anchors.baseline: projectNameTextLabel.baseline
                    }
                }

                Column{
                    spacing: dp(7)
                    Repeater{
                        model: reportModel ? reportModel : 0
                        Row{
                            spacing: dp(5)
                            AppTextFieldLabel{
                                id: calendarWeekText
                                text: "KW"+ modelData.week + ":"
                            }

                            AppText{
                                id: weekTotalText
                                text: modelData.result + "h"
                                anchors.baseline: calendarWeekText.baseline
                            }
                        }
                    }
                }
            }
        }
    }

    \endcode

*/
