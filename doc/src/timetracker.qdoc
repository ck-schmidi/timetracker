/*!
    \example timetracker
    \title Simple Timetracker Tutorial
    \brief Demonstrates how to use V-Play to build a timetracking application

    This tutorial will show you how to use V-Play-Apps and QtQuick for creating
    a simple timetracking application.

    \section1 Goal
    The goal of this tutorial is creating a data-based mobile app. We want to have the
    possibility to add and configure projects, where we can then add timetrackings. We
    want to persist this data in a local storage. For this purpose we will use
    \b {Qt Quick Local Storage}. \b{Qt Quick Local Storage} uses a local sqlite database
    for saving the data. The tutorial will also cover how navigation between
    different screens in V-Play-Apps works. We will also build some new controls, like
    a timepicker which is used for selecting a time.

    \section1 Let's get started
    For creating a new V-Play-App we go to \b{File -> New File Or Project} and then
    select \b{Empty Application} in section \b{Project/V-Play Apps}. Select a appropriate
    project-name (I chose \b{timetracking}) and click \b{Next}. Choose the latest
    installed Qt-Version and click \b{Next}. In the next screen you have to enter the app
    display name and the app-identifier. I chose \b{Timetracker} and
    \b{at.codekitchen.timetracker}. Interface orientation can be let to \b{Auto}.
    Choose your prefered source code management tool in the next screen and click
    \b{Finish}

    \section1 Structure
    We will provide the following top-level navigation-structure
    \list
       \li Projects
       \li Tracking
       \li Reports
    \endlist

    So we want to end up with something like this:

    # add screenshot

    Now, let's dive into some code. Open the file \c{qml/Main.qml}

    For top-level navigation we use the V-Play component \c Navigation. \c Navigation is
    renders platform-specific, for example if you are on Android it renders a Drawer-based
    navigation. In iOS its a tab-based navigation.

    So lets build up our top-level UI-Structure by removing whats currently inside \c App
    and add a \c Navigation component with 3x \c NavigationItem as its children for each
    Navigation Entry. \c NavigationItem can be parameterized with a title and an icon. For
    the icons we use the V-Play compontent IconType for getting nice FontAwesome icons.

    \code
    import VPlayApps 1.0

    App {
        Navigation {
            NavigationItem {
                title: qsTr("Trackings")
                icon: IconType.list
            }

            NavigationItem {
                title: qsTr("Projects")
                icon: IconType.trello
            }

            NavigationItem{
                title: qsTr("Reports")
                icon: IconType.file
            }
        }
    }
    \endcode

    If we \b {Build an Run} or project we should see the top-level-navigation of our
    application.


    \section1 Database
    Before we get into programming our different screens, we should talk about the datastructures
    we use in our program.

    We have a simple data structure:

    \code
                                          +-------------------+
        +-------------------+             | Track             |
        | Project           |             +-------------------+
        +-------------------+             |# comment          |
        |# name             |             |# from             |
        |# description      <-------------+# to               |
        +-------------------+             +-------------------+
    \endcode

    We want to organize projects and we want to have timetrackings (track) which can be
    assigned to one of this projects. So lets create a new qml-file \c{qml/Database.qml}
    for encapsulating all our model/database logic.

    In our \c Database component we need to create a database-connection to our \c LocalStorage
    (will be done in the \c{init} function). The result of the connection is saved in the local
    property db. We also hold two models: \c projectModel for managing projects and trackModel
    for managing our timetrackings.

    For every model we also need some extra logic for handling the model <-> database logic

    In this case we have to Daos (DataAccessObjects) which have following functions:
    \list
       \li \c{populate}: \e{populates the model from database}
       \li \c{append(item)}: \e{appends an new item to the model}
       \li \c{remove(index)}: \e(removes an item from the model by given index}
       \li \c{save(index)}: \e{(saves an item from the model by given index)}
    \endlist

    The base structure of this component should look like:

    \code

    Item {
        id: database
        property var db

        property ListModel projectModel: ListModel{}
        property ListModel trackModel: ListModel{}

        function init(){}

        property var projectDao : QtObject{
            function populate(){}
            function append(project){}
            function remove(modelIndex){}
            function save(modelIndex){}
        }

        property var trackDao: QtObject{
            function populate(){}
            function append(track){}
            function remove(modelIndex){}
            function save(modelIndex){}
        }

        Component.onCompleted: {
            database.init()
            database.projectDao.populate()
            database.trackDao.populate()
        }
    }

    \endcode

    Now we get into the individual functions. Let's start with the \c{init()}-function.
    In this function we need to do following things:

    \list
        \li set up database connection
        \li create database-structure (only on first startup)
    \endlist

    For setting up our database connection we use the function \c{openDataBaseSync(â€¦)} from
    the LocalStorage QML-componentAfter setting the connection up, we execute the create-statement
    for our database. You should use the 'IF NOT EXISTS'-clause on the create-statements, then the
    statement is only executed on the first startup of the application.

    \code

    function init(){
        db = LocalStorage.openDatabaseSync("TimeTrackingDB", "1.0", "Timetracking Database", 100000);
        db.transaction( function(tx) {
            tx.executeSql('CREATE TABLE IF NOT EXISTS PROJECT(id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT, description TEXT)')
            tx.executeSql('CREATE TABLE IF NOT EXISTS TRACK(id INTEGER PRIMARY KEY AUTOINCREMENT, comment TEXT, projectid INTEGER, start DATETIME, end DATETIME)')
        });
    }

    \endcode

    If we \b{Build and Run} our application after implementing the \c{init}-function and doesn't
    get any error, the connection succeeded and the database and its tables were created.


    Now let's implement the playerDao and let's start with the \c{populate}-function:

    \list
        \li We first check, if we our db property has a value. if not -> return false
        \li If we have a valid database-connection we start a transaction
        \li In this transaction we execute the statement 'SELECT * FROM PROJECT' which returns all entries in table PROJECT
        \li In the next step we iterate the result-set of this statement and add the project to our projectModel
    \endlist

    As you can see, we also save us the \c rowId of the database-entry, so we can identify our project-item for updates and
    deletions. We use the javascript \c{parseInt} function for converting the id from the database to an int-value.

    \code
    function populate(){
        if(!db){ return false; }

        db.transaction(function(tx){
            var result = tx.executeSql('SELECT * FROM PROJECT')
            for(var i = 0; i < result.rows.length; i++){
                var item = result.rows.item(i)
                projectModel.append({"rowId": parseInt(item.id), "name": item.name, "description": item.description})
            }
        });
        return true;
    }
    \endcode

    In the next step we will take a look on the \c{append}-function:

    \list
        \li For continuity we reset our name and description properties to an empty string, if they are undefined
        \li In the next step we execute an INSERT-statement with our project-properties name and description
        \li After the execution of the statement we save the retured rowId from the database and add the item to our model
    \endlist

    \code
    function append(project){
        project.name = project.name !== undefined ? project.name : ""
        project.description = project.description !== undefined ? project.description: ""
        db.transaction( function(tx) {
            var res = tx.executeSql('INSERT INTO PROJECT (name, description) VALUES(?, ?)', [project.name, project.description])
            //change rowId before inserting to model
            project.rowId = parseInt(res.insertId)
        })
        projectModel.append(project)
        return projectModel.count - 1
    }
    \endcode

    Now lets implement the remove function:

    \list
        \li The remove-function takes the modelIndex as a parameter, so we take our project from the model with the given index
        \li In the next step again open a database-transaction and execute the DELETE-statement
        \li For checking the success of the delete-statement we check the rowsAffected property on our statement-result
        \li If the deletion was successful, we remove the given project from our model and return true, otherwise we return false
    \endlist

    \code
    function remove(modelIndex){
        var project = projectModel.get(modelIndex)
        var success
        db.transaction( function(tx) {
            var res = tx.executeSql('DELETE FROM PROJECT WHERE id = ?', [project.rowId])
            success = res.rowsAffected > 0
        })

        if(!success) { return false; }
        projectModel.remove(modelIndex)
        return true
    }
    \endcode


    In the last step of the \c{projectDao} implementation we implement to \c{save} function.

    \list
        \li similar to the remove-function we first get the project from the model with the given index
        \li In the next step we open a new database-transaction and execute the UPDATE-statement
        \li If res.rowsAffected > 0, we return true, otherwise we return false
    \endlist

    \code
    function save(modelIndex){
        var project = projectModel.get(modelIndex)
        var success
        db.transaction(function(tx){
            var res = tx.executeSql('UPDATE PROJECT SET name = ?, description = ? WHERE id = ?', [project.name, project.description, project.rowId])
            success = res.rowsAffected > 0
        });
        return success
    }
    \endcode


   The DAO-Code for the trackDao is pretty similar to the projectModel.
   I'll outline the main differences, but I won't go into every function explicitly.

   The main difference to the projectModel is, that we have to care about the
   relationship between the track and the project.

   \list
       \li {In the function populate() we also save the projectRowId as our foreign-key}
   \endlist

    \code

    //holds all the model-functionality for trackModel
    property var trackDao: QtObject{
        function populate(){
            if(!db){ return false; }
            db.transaction(function(tx){
                var result = tx.executeSql('SELECT * FROM TRACK')
                for(var i = 0; i < result.rows.length; i++){
                    var item = result.rows.item(i)
                    trackModel.append({"rowId": parseInt(item.id),
                                       "comment": item.comment,
                                       "projectRowId": item.projectid,
                                       "start": item.start,
                                       "end": item.end})
                }
            });
            return true;
        }

        //append new track to trackModel
        function append(track){
            track.comment = track.comment !== undefined ? track.comment : ""
            track.start = Date.now()
            track.projectRowId = track.projectRowId !== undefined ? track.projectRowId : ""
            var res
            db.transaction( function(tx) {
                res = tx.executeSql('INSERT INTO TRACK(comment, start) VALUES(?, ?)', [track.comment, track.start])
                track.rowId = parseInt(res.insertId)
            })
            trackModel.append(track)
            return trackModel.count - 1
        }

        function remove(modelIndex){
            var track = trackModel.get(modelIndex)
            var success
            db.transaction( function(tx) {
                var res = tx.executeSql('DELETE FROM TRACK WHERE id = ?', [track.rowId])
                success = res.rowsAffected > 0
            })
            if(!success) { return success; }
            trackModel.remove(modelIndex)
            return success
        }

        function save(modelIndex){
            var track = trackModel.get(modelIndex)
            var success
            db.transaction(function(tx){
                var res = tx.executeSql('UPDATE TRACK SET comment = ?, start = ?, end = ?, projectid = ? WHERE id = ?',
                                        [track.comment, track.start, track.end, track.projectRowId])
                success = res.rowsAffected > 0
            });
            return success
        }
    }


    \endcode


    \section1 Screen ProjectsPage

    We want to have a screen, where we can Add, Modify and Delete projects.
    When we go to the screen it should look like:

    # todo insert screenshot
    Let's create an empty QML-Component \c{ProjectsPage.qml} for our visual implementation.

    After creating the new qml-file lets use it in our \c{Main.qml} component within a \c{NavigationStack} (needed
    for our Detail-Page)

    \code
        ...

        NavigationItem {
            title: qsTr("Projects")
            icon: IconType.trello

            NavigationStack{
                ProjectsPage{}
            }
        }
        ...

    \endcode

    Now lets dive into \c{ProjectsPage.qml}

    Our toplevel-component is a \c{ListPage} where we set the title to 'Projects'

    \code

    ListPage {
        title: qsTr("Projects")
        ...
    }

    \endcode


    For adding new projects we add a "+" - Button to the rightBarItem

    \code
    ListPage{
        ...
        rightBarItem: IconButtonBarItem {
            icon: IconType.plus
        }
        ...
    \endcode


    Now we need a \c{ListView} for showing our entries from the database.

    Let's add a \c{AppListView}, which provides a nice device-independent \c{ListView}

    \c{AppListView} takes our database.projectModel as a model and we use the \c{SimpleRow}
    delegate for displaying our data (text should be the (project)name, detailText
    the (project)description)

    \code

    ListPage{
        ...
        AppListView {
            id: appListView
            model: database.projectModel
            delegate: SimpleRow {
                text: name
                detailText: description
            }
        }
        ...
    \endcode


    For using our database we need to instantiate it in global scope (\c{Main.qml})
    In this step we also add the \c{id} app (we will need this later)

    \code
    App {
        id: app

        Database{
            id: database
        }
        ...

    \endcode

    After this step we are able to show project-entries from the model (database)

    In the next step we want to provide functionality for adding new projects.

    So, let's add a function which opens a Dialog with a TextField for entering the
    name of the new project.

    \c{InputDialog} is a V-Play Component which provides single and multiline
    InputDialogs. In this case we one need a singleline input so we use the function
    \c{inputTextSingleLine}. It takes the topel-level app, a title, a placeholder-text
    and a callback-function, where we can handle the users actions and inputs.

    In the callback-function we check if "Cancel" was pressed (!ok) or the input-text
    is empty. If one of these conditions is true, we return and do nothing

    Otherwise we call our \c{projectDao.append(...)} function.

    \code
    function createNewProject(){
        InputDialog.inputTextSingleLine(app,
                                        qsTr("Create new Project"),
                                        qsTr("Project Name"),
                                        function (ok, text) {
                                            if (!ok || text === "") {
                                                return
                                            }
                                            database.projectDao.append({"name": text, "description": "")
                                        })
    }
    \endcode

    Let's use this function on our rightBarItem in the onClicked event-handler:

    \code
    rightBarItem: IconButtonBarItem {
        ...
        onClicked: createNewProject()
    }
    \endcode

    Now we are able to create new projects by clicking the "+"-Button and filling the LineEdit.

    In the next step we implement a DetailScreen for our ListView.

    For this purpose we create a new component inside our \c{ProjectsPage}
    The component holds a page with the title 'Detail View'

    We add two properties \c{projectIndex} + \c{project}.
    \c{projectIndex} is used as parameter for the DetailView

    \code

    ListPage {
        ...
        Component {
        id: detailView
            Page {
                id: page
                title: qsTr("Detail View")

                property int projectIndex
                property var project: database.projectModel.get(projectIndex)
            }
        }
        ...
    \endcode

    For using this component we have to extend our implementation of our \c{AppListView}
    We add a function \c{switchTo(index)} for pushing our detailView to our navigationStack
    and use it in our \c{SimpleRow}-delegate

    \code
    AppListView {
        ...
        delegate: SimpleRow {
            ...
            onSelected: appListView.switchTo(index)
        }
        ...
        function switchTo(index) {
            navigationStack.push(detailView, { projectIndex: index })
        }
        ...
    \endcode

    We can also change our \c{createNewProject} function to switch to the detail-screen
    after creating the new project

    \code

    function createNewProject(){
        ...
                                            appListView.switchTo(database.projectDao.append({"name": text, "description": ""}))
        ...
    }

    \endcode

    Now lets extend our DetailView for editing the project:

    In the first step we add a \c{Column} container for providing all our labels and textfields:

    We use the VPlay-App components \c{AppText} and \c{AppTextField} for the labels and textfields:

    \code
    Component {
        id: detailView
        Page {
            ...
            Column{
                spacing: dp(5)
                topPadding: dp(15)
                padding: dp(5)

                AppText{
                    id: projectNameLabel
                    text: qsTr("Project Name:")
                    font.pixelSize: sp(10)
                    color: "grey"
                }

                AppTextField{
                    id: projectNameTextField
                    text:  project ? project.name : ""
                }

                AppText{
                    id: projectDescriptionLabel
                    text: qsTr("Project Description:")
                    font.pixelSize: sp(10)
                    color: "grey"
                }

                AppTextField{
                    id: projectDescriptionTextField
                    text:  project ? project.description: ""
                }
            }
            ...
    \endcode

    After that change, our DetailView shows the correct informations from the database, but
    editing still doesn't work correctly

    We have to add the Bindings for 2-way-property binding (see: \l{http://imaginativethinking.ca/bi-directional-data-binding-qt-quick/})
    and we add a timer for saving our changes (not too often ;))

    \code
        Binding{
            target: project
            property: "name"
            value: projectNameTextField.text
        }

        Binding{
            target: project
            property: "description"
            value: projectDescriptionTextField.text
        }

        Timer{
            id: saveTimer
            interval: 500
            running: false
            repeat: false
            onTriggered: database.projectDao.save(projectIndex)
        }
    \endcode

    we need to call this functions when our texts in the textfields gets changed

    \code

    AppTextField{
        id: projectNameTextField
        ...
        onTextChanged: saveTimer.restart()
    }

    AppTextField{
        id: projectDescriptionTextField
        ...
        onTextChanged: saveTimer.restart()
    }

    \endcode

    Our last task for the Project-Detail-View is adding a delete button:

    In this case we create a new folder components with a new QML-Component-File
    \c{DeleteButton.qml} which encapsulates our DeleteButton. We use the \c{AppButton}
    component from V-Play-Apps with a remove-icon and text "delete" and some appropriate
    colors.

    \code
    AppButton{
        id: deleteButton
        text: qsTr("delete")
        icon: IconType.remove
        backgroundColor: "red"
        backgroundColorPressed: "purple"
    }
    \endcode

    Similar to the text creating we again use the \c{InputDialog} component
    for creating an Dialog. In this case we just want to confirm the deletion.
    If the user confirms the deletion, we use our model-functions to remove it

    \code
            Column{
                ...
                DeleteButton{
                    id: deleteButton
                    onClicked: {
                        InputDialog.confirm(app,
                           qsTr("Really wanna delete project %1?".arg(project.name)),
                           function (ok) {
                               if (!ok) { return; }
                               database.projectDao.remove(page.projectIndex)
                               navigationStack.pop()
                           })
                    }
                }
            }
    \endcode

    Now we are done with the ProjectView.

    \section1 Screen TrackingsPage

    \c{TrackingsPage} is pretty similar to \c{ProjectsPage}. It contains a \c{ListView} with
    all trackings, an Add-Button and a DetailView.

    Let's create a QML-component \c{TrackingsPage.qml}

    Again, I won't go too much into the details, because its very similar to the ProjectsPage.
    Instead of opening a Dialog when clicking the "+"-Button, we directly append a new track
    to the model and switch to the DetailView for editing.


    # todo: explain getProjectByRowId(...)

    \code

    ListPage{
        id: trackingsPage
        title: qsTr("Trackings")

        Component{
            id: detailView
            Page{
                title: qsTr("Detail View")
            }
        }

        rightBarItem: IconButtonBarItem {
            icon: IconType.plus
            onClicked: {
                appListView.switchTo(database.trackDao.append({comment: ""}))
            }
        }

        AppListView{
            id: appListView
            model: database.trackModel

            delegate: SimpleRow {
                text: "Project: %1".arg(database.projectDao.getProjectByRowId(model.projectRowId))
                detailText: "%1 (%2)".arg(Helpers.formatDate(model.start)).arg(model.comment)
                onSelected: appListView.switchTo(index)
            }

            function switchTo(index) {
                navigationStack.push(detailView, { projectIndex: index })
            }
        }
    }

    \endcode

    In our \c{SimpleRow} delegate we use a helper-function formatDate(...) which we put in a new file \c{helpers.js}
    This function does the formatting of your date.

    \code

    .pragma library

    function formatDate(dt)
    {
        dt = new Date(dt);

        var formattedDate = '%1.%2.%3 %4:%5'
        .arg(padLeft(dt.getDate(), '0', 2))
        .arg(padLeft(dt.getMonth() + 1, '0', 2))
        .arg(dt.getFullYear())
        .arg(padLeft(dt.getHours(), '0', 2))
        .arg(padLeft(dt.getMinutes(), '0', 2))

        return formattedDate
    }

    function padLeft(str, ch, width)
    {
        var s = String(str);

        while (s.length < width)
        s = ch + s;

        return s;
    }

    \endcode


    Now we can use the \c{TrackingsPage} in \c{Main.qml}

    \code
    Navigation {
        NavigationItem {
            ...
            NavigationStack{
                TrackingsPage{}
            }
        }
    \endcode

    In the next step we will create some components, which we will later on need for
    our TrackingsPage. We will start with the TimePicker.

    Let's create a new file \c{TimePicker.qml} in the folder components.

    The implementation of \c{TimePicker.qml} is pretty straight-forward

    \list
        \li As top-level component we choose Item
        \li Lets add a property visibleItem for configuring how many items  should be shown in the tumbler-list
        \li Create a Text-Component for our Tumbler-delegate which cares about the styling of the single text-line
        \li Add a row with 2 Tumblers (one for hours, one four minutes) + identify them by setting an id
        \li Lets add the property aliases currentHours and currentMinutes to our Tumblers curent index
        \li For simpler usage we provide a new signal anyValueChanged which is fired by onCurrentHoursChanged and onCurrentMinutesChanged
    \endlist

    \code
    import VPlay 2.0
    import QtQuick 2.7
    import QtQuick.Controls 2.0

    Item{
        height: dp(100)
        width: row.width

        property int visibleItems: 3
        property alias currentHours: hourTumbler.currentIndex
        property alias currentMinutes: minutesTumbler.currentIndex

        signal anyValueChanged

        onCurrentHoursChanged: anyValueChanged()
        onCurrentMinutesChanged: anyValueChanged()

        Component{
            id: tumblerDelegate
            Text{
                text: {
                    if(modelData < 10)
                        return "0" + modelData
                    return modelData
                }
                horizontalAlignment: Text.AlignHCenter
                verticalAlignment: Text.AlignVCenter
                font.pixelSize: dp(20)
                opacity: 1.0 - Math.abs(Tumbler.displacement) / (visibleItems / 2)
            }
        }

        Row{
            id: row
            Tumbler {
                id: hourTumbler
                width: dp(50)
                model: 24
                delegate: tumblerDelegate
            }
            Tumbler {
                id: minutesTumbler
                width: dp(50)
                model: 60
                delegate: tumblerDelegate
            }
        }
    }
    \endcode

    Another component we will probably need at some more points will be a \c{AppTextFieldLabel} which
    is used for labeling controls on the screens.

    We just set \c{font.pixelSize} and \c{color} to some appropriate values.

    \code

    import VPlayApps 1.0
    import QtQuick 2.0

    AppText{
        font.pixelSize: sp(10)
        color: "grey"
    }

    \endcode




*/
